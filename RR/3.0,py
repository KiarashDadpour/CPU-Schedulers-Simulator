import matplotlib.pyplot as plt
from collections import deque


def average(lst):
    return sum(lst) / len(lst)


def round_robin(p, at, cbt, cs, quantum):
    # Create copies of original data
    remaining_time = cbt.copy()
    arrival_times = at.copy() 

    # Initialize tracking variables
    waiting_times = [0] * p
    turnaround_times = [0] * p
    completion_times = [0] * p
    timeline = []

    current_time = 0
    ready_queue = deque()
    completed_processes = 0

    while completed_processes < p:
        # Find and add newly arrived processes to the queue
        for i in range(p):
            if arrival_times[i] <= current_time and remaining_time[i] > 0:
                # Avoid duplicates in queue
                if i not in ready_queue:
                    ready_queue.append(i)

        # If no processes are ready, move time forward
        if not ready_queue:
            current_time += 1
            continue

        # Get the first process in the queue
        current_process = ready_queue.popleft()

        # Record start time
        start_time = current_time

        # Determine execution time
        execute_time = min(quantum, remaining_time[current_process])

        # Update current time and remaining time
        current_time += execute_time
        remaining_time[current_process] -= execute_time

        # Record timeline
        timeline.append((
            current_process + 1,  # Process ID (1-based)
            start_time,  # Start time
            current_time  # End time
        ))

        # Add context switch time
        current_time += cs

        # Check if process is completed
        if remaining_time[current_process] <= 0:
            completed_processes += 1
            completion_times[current_process] = current_time

            # Calculate waiting and turnaround times
            turnaround_times[current_process] = (
                    completion_times[current_process] - arrival_times[current_process]
            )
            waiting_times[current_process] = (
                    turnaround_times[current_process] - cbt[current_process]
            )
        else:
            # If not completed, find and add newly arrived processes
            for i in range(p):
                if (arrival_times[i] <= current_time and
                        remaining_time[i] > 0 and
                        i not in ready_queue and
                        i != current_process):
                    ready_queue.append(i)

            # Put current process back to the end of the queue
            ready_queue.append(current_process)

    return waiting_times, turnaround_times, timeline

def plot_gantt_rr(timeline, cs):
    fig, ax = plt.subplots(figsize=(10, 6))
    half_cs = cs / 2  # Compute half of CS time

    for i, process in enumerate(timeline):
        index, start, end = process
        y_pos = index * 1.5  # Increase vertical spacing between processes

        # Draw the process bar in blue
        ax.broken_barh([(start, end - start)], (y_pos - 0.4, 0.8), facecolors='tab:blue')

        # Draw the second half of CS at the end of the current process
        if cs > 0 and i < len(timeline) - 1:
            cs_start = end
            ax.broken_barh([(cs_start, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:red', alpha=0.5)

        # Draw the first half of CS at the start of the next process
        if cs > 0 and i < len(timeline) - 1:
            next_start = timeline[i + 1][1]
            cs_start_next = next_start - half_cs
            ax.broken_barh([(cs_start_next, half_cs)], ((timeline[i + 1][0] * 1.5) - 0.4, 0.8), facecolors='tab:orange', alpha=0.5)

    # Add CS time at the end of the last process
    if cs > 0:
        last_process_end = timeline[-1][2]
        ax.broken_barh([(last_process_end, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:green', alpha=0.5)

    ax.set_ylim(0, len(timeline))
    ax.set_xlim(0, max(t[2] for t in timeline) + cs)
    ax.set_xlabel("Time")
    ax.set_ylabel("Processes")
    ax.set_yticks([t[0] * 1.5 for t in timeline])
    ax.set_yticklabels([f"P{t[0]}" for t in timeline])
    ax.grid(True)
    max_time = max(t[2] for t in timeline) + cs
    ax.set_xticks(range(0, max_time + 1, 2))
    plt.title("Round Robin")
    plt.show()

# Input data
p = 5
at = [0, 2, 3, 4, 5]
cbt = [10, 8, 3, 7, 12]
cs = 1
quantum = 5

# Execute Round Robin
a, b, timeline = round_robin(p, at, cbt, cs, quantum)
print("Waiting Times:", a)
print("Turnaround Times:", b)

wtbar = average(a, p)
ttbar = average(b, p)
print("Average of WT: ", wtbar)
print("Average of TT: ", ttbar)

# Plot Gantt chart
plot_gantt_rr(timeline, cs)
