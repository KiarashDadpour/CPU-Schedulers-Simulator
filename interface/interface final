import customtkinter
from matplotlib.figure import Figure
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from PIL import Image, ImageTk
import threading
from collections import deque

# from tkinter import Canvas, Frame, Scrollbar
class InfoPage(customtkinter.CTkToplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("Info Page")
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()       
        self.geometry(f"{screen_width}x{screen_height}") # اندازه دلخواه
        scrollable_frame = customtkinter.CTkScrollableFrame(self, width=580, text=" ", height=380)
        scrollable_frame.pack(padx=10, pady=10, fill="both", expand=True)
        
class ContactPage(customtkinter.CTkToplevel):
    def __init__(self, parent):
        super().__init__(parent)
        self.title("Contact Page")
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()       
        self.geometry(f"{screen_width}x{screen_height}")  
        self.rowconfigure(0, weight=0 )
        self.rowconfigure(1, weight=0)
        self.rowconfigure(2, weight=1)
        self.columnconfigure(0, weight=0)
        self.columnconfigure(1, weight=0)
        self.columnconfigure(2, weight=0)
        image_kia = Image.open("./kiarash.jpeg")  
        image_kia = image_kia.resize((200, 200))  
        photo = ImageTk.PhotoImage(image_kia)
        image_label_kia = customtkinter.CTkLabel(self, image=photo, text="")
        image_label_kia.image = photo  
        image_label_kia.grid(row=0, column=0, padx=(250,100), pady=50, sticky="nsew")
        image_asal = Image.open("./kiarash.jpeg")  
        image_asal = image_asal.resize((200, 200))  
        photo = ImageTk.PhotoImage(image_asal)
        image_label_asal = customtkinter.CTkLabel(self, image=photo, text="")
        image_label_asal.image = photo  
        image_label_asal.grid(row=0, column=1, padx=100, pady=50, sticky="nsew")
        image_pari = Image.open("./kiarash.jpeg")  
        image_pari = image_pari.resize((200, 200)) 
        photo = ImageTk.PhotoImage(image_pari)
        image_label_pari = customtkinter.CTkLabel(self, image=photo, text="")
        image_label_pari.image = photo  
        image_label_pari.grid(row=0, column=2, padx=(100,250), pady=50, sticky="nsew")
        label_kia = customtkinter.CTkLabel(self, text="email kia", font=("Arial", 16))
        label_kia.grid(row=1, column=0, padx=(250,100), pady=50, sticky="nsew")
        image_label_asal = customtkinter.CTkLabel(self, text="email asal", font=("Arial", 16))
        image_label_asal.grid(row=1, column=1, padx=(100,100), pady=50, sticky="nsew")
        image_label_pari = customtkinter.CTkLabel(self, text="pari041503@gmail.com", font=("Arial", 16))
        image_label_pari.grid(row=1, column=2, padx=(100,250), pady=50, sticky="nsew")
        close_button = customtkinter.CTkButton(self, text="Close", command=self.destroy)
        close_button.grid(row=2, column=1, pady=30, sticky="s")
        
def average(lst):
    return sum(lst) / len(lst)   
        
### FCFS
def fcfs(p, at: list, cbt: list, cs=1):
    current_time = 0
    WT = [0] * p
    TT = [0] * p
    timeline = []

    ready_queue = deque(range(p))

    while ready_queue:
        process = ready_queue.popleft()

        if current_time < at[process]: 
            current_time = at[process]
        start_time = current_time
        end_time = start_time + cbt[process]
        wt = start_time - at[process]
        tt = end_time - at[process]

        WT[process] = wt
        TT[process] = tt

        timeline.append((process + 1, start_time, end_time))

        current_time = end_time + cs
    RT = TT
    return WT, TT, RT,  timeline

def plot_gantt_fcfs(timeline, cs):
    fig = Figure(figsize=(10, 4), dpi=100)
    ax = fig.add_subplot(111)
    half_cs = cs / 2  

    for i, process in enumerate(timeline):
        index, start, end = process
        y_pos = index * 1.47
        ax.broken_barh([(start, end - start)], (y_pos - 0.4, 0.8), facecolors='tab:blue')
        if cs > 0 and i < len(timeline) - 1:
            cs_start = end
            ax.broken_barh([(cs_start, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:red', alpha=0.5)
        if cs > 0 and i < len(timeline) - 1:
            next_start = timeline[i + 1][1]
            cs_start_next = next_start - half_cs
            ax.broken_barh([(cs_start_next, half_cs)], ((timeline[i + 1][0] * 1.47) - 0.4, 0.8), facecolors='tab:orange', alpha=0.5)
    if cs > 0:
        last_process_end = timeline[-1][2]
        ax.broken_barh([(last_process_end, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:green', alpha=0.5)

    ax.set_ylim(0, len(timeline))
    ax.set_xlim(0, max(t[2] for t in timeline) + cs)
    ax.set_xlabel("Time")
    ax.set_ylabel("Processes")
    ax.set_yticks([t[0] * 1.59 for t in timeline])
    ax.set_yticklabels([f"P{t[0]}" for t in timeline])
    ax.grid(True)
    max_time = max(t[2] for t in timeline) + cs
    ax.set_xticks(range(0, max_time + 1, 2))
    ax.set_title("FCFS Gantt Chart")
    return fig


###  RR
def round_robin(p, at, cbt, cs, quantum):
    cbt1 = cbt.copy()
    at1 = at.copy()

    WT = [0] * p 
    TT = [0] * p  
    RT = [float('inf')] * p  
    timeline = []

    current_time = 0
    ready_queue = deque()
    completed_processes = 0
    first_run = [True] * p  

    for i in range(p):
        if at1[i] <= current_time and cbt[i] > 0:
            if i not in ready_queue:
                ready_queue.append(i)

    while completed_processes < p:
        if not ready_queue:
            current_time += 1
            continue

        current_process = ready_queue.popleft()

        if first_run[current_process]:
            RT[current_process] = current_time - at1[current_process]
            first_run[current_process] = False

        start_time = current_time
        running_time = min(quantum, cbt[current_process])

        current_time += running_time
        cbt[current_process] -= running_time

        timeline.append((current_process + 1, start_time, current_time))

        current_time += cs
        if cbt[current_process] <= 0:
            completed_processes += 1
            TT[current_process] = current_time - at1[current_process]
            WT[current_process] = TT[current_process] - cbt1[current_process]
        else:
            for i in range(p):
                if at1[i] <= current_time and  cbt[i] > 0 and  i not in ready_queue and i != current_process:
                    ready_queue.append(i)

            ready_queue.append(current_process)

    return WT, TT, RT, timeline



def plot_gantt_rr(timeline, cs):
    fig = Figure(figsize=(10, 4), dpi=100)
    ax = fig.add_subplot(111)
    half_cs = cs / 2  # Compute half of CS time

    for i, process in enumerate(timeline):
        index, start, end = process
        y_pos = index * 1.5
        ax.broken_barh([(start, end - start)], (y_pos - 0.4, 0.8), facecolors='tab:blue')
        if cs > 0 and i < len(timeline) - 1:
            cs_start = end
            ax.broken_barh([(cs_start, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:red', alpha=0.5)
        if cs > 0 and i < len(timeline) - 1:
            next_start = timeline[i + 1][1]
            cs_start_next = next_start - half_cs
            ax.broken_barh([(cs_start_next, half_cs)], ((timeline[i + 1][0] * 1.5) - 0.4, 0.8), facecolors='tab:orange', alpha=0.5)
    if cs > 0:
        last_process_end = timeline[-1][2]
        ax.broken_barh([(last_process_end, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:green', alpha=0.5)

    ax.set_ylim(0, len(timeline))
    ax.set_xlim(0, max(t[2] for t in timeline) + cs)
    ax.set_xlabel("Time")
    ax.set_ylabel("Processes")
    ax.set_yticks([t[0] * 1.5 for t in timeline])
    ax.set_yticklabels([f"P{t[0]}" for t in timeline])
    ax.grid(True)
    max_time = max(t[2] for t in timeline) + cs
    ax.set_xticks(range(0, max_time + 1, 2))
    ax.set_title("RR Gantt Chart")
    return fig



### SPN
def spn(p, at: list, cbt: list, cs: int):
    current_time = 0
    WT = deque([0] * p)
    TT = deque([0] * p)

    completed_count = 0
    completed = deque([False] * p)
    timeline = deque()

    while completed_count < p:
        Q = deque()
        for process in range(p):
            if at[process] <= current_time and not completed[process]:
                Q.append(process)

        if not Q:
            current_time += 1
            continue

        shortest_process = find_min(Q, cbt)

        start_time = current_time
        current_time += cbt[shortest_process]
        TT[shortest_process] = current_time - at[shortest_process]
        WT[shortest_process] = TT[shortest_process] - cbt[shortest_process]

        completed[shortest_process] = True
        completed_count += 1
        timeline.append((shortest_process + 1, start_time, current_time))

        current_time += cs
    RT = WT
    return WT, TT, RT, timeline

def find_min(Q: deque, cbt: list):
    min_value = float("inf")
    index_value = -1
    for index in Q:
        if cbt[index] < min_value:
            min_value = cbt[index]
            index_value = index
    return index_value

def plot_gantt_spn(timeline, cs):
    fig = Figure(figsize=(10, 6), dpi=100)
    ax = fig.add_subplot(111)
    half_cs = cs / 2  # Compute half of CS time

    for i, process in enumerate(timeline):
        index, start, end = process
        y_pos = index * 1.5

        # Draw the process bar in blue
        ax.broken_barh([(start, end - start)], (y_pos - 0.4, 0.8), facecolors='tab:blue')

        if cs > 0 and i < len(timeline) - 1:
            cs_start = end
            ax.broken_barh([(cs_start, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:red', alpha=0.5)

        if cs > 0 and i < len(timeline) - 1:
            next_start = timeline[i + 1][1]
            cs_start_next = next_start - half_cs
            ax.broken_barh([(cs_start_next, half_cs)], ((timeline[i + 1][0] * 1.5) - 0.4, 0.8), facecolors='tab:orange', alpha=0.5)

    if cs > 0:
        last_process_end = timeline[-1][2]
        ax.broken_barh([(last_process_end, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:green', alpha=0.5)

    ax.set_ylim(0, (len(timeline) + 1) * 1.5)
    ax.set_xlim(0, max(t[2] for t in timeline) + cs)
    ax.set_xlabel("Time")
    ax.set_ylabel("Processes")
    ax.set_yticks([t[0] * 1.5 for t in timeline])
    ax.set_yticklabels([f"P{t[0]}" for t in timeline])
    ax.grid(True)
    max_time = max(t[2] for t in timeline) + cs
    ax.set_xticks(range(0, max_time + 1, 2))
    ax.set_title("SPN Gantt Chart")
    return fig

### HRRN
def hrrn(p, at, cbt, cs):
    current_time = 0
    WT = [0] * p
    TT = [0] * p
    completed = [False] * p
    timeline = []
    completed_count = 0

    while completed_count < p:
        # Find ready processes
        ready_processes = find_ready_processes(p, at, current_time, completed)

        if len(ready_processes) == 0:
            # If no process is ready, move to the next process's arrival time
            next_arrival = float('inf')
            for i in range(p):
                if not completed[i]:
                    next_arrival = min(next_arrival, at[i])
            current_time = next_arrival
            continue

        # Calculate Response Ratios
        response_ratios = calculate_rpr(ready_processes, current_time, at, cbt)

        # Find process with highest response ratio
        max_index = find_max_rpr(response_ratios, at)

        # Execute the selected process
        start_time = current_time
        current_time += cbt[max_index]
        end_time = current_time

        # Update TT and WT
        TT[max_index] = end_time - at[max_index]  # Turnaround Time
        WT[max_index] = TT[max_index] - cbt[max_index]  # Waiting Time

        # Mark process as completed
        completed[max_index] = True
        completed_count += 1

        # Add process to the timeline
        timeline.append((max_index + 1, start_time, end_time))

        # Add context switch time
        current_time += cs

    return WT, TT, timeline

def find_ready_processes(p, at, current_time, completed):
    ready_processes = []
    for i in range(p):
        if at[i] <= current_time and not completed[i]:
            ready_processes.append(i)
    return ready_processes

def find_max_rpr(rprs, at):
    max_ratio = -1
    max_index = -1

    for i, (ratio, process) in enumerate(rprs):
        if ratio > max_ratio:
            max_ratio = ratio
            max_index = i
        elif ratio == max_ratio:
            # If ratios are equal, choose process with earlier arrival time
            if at[process] < at[rprs[max_index][1]]:
                max_index = i

    return rprs[max_index][1]

def calculate_rpr(ready_processes, current_time, at, cbt):
    rprs = []
    for process in ready_processes:
        waiting_time = max(0, current_time - at[process])
        rpr = (waiting_time + cbt[process]) / cbt[process]
        rprs.append((rpr, process))
    return rprs

def plot_gantt_hrrn(timeline, cs):
    fig = Figure(figsize=(10, 6), dpi=100)
    ax = fig.add_subplot(111)
    half_cs = cs / 2  # Compute half of CS time

    for i, process in enumerate(timeline):
        index, start, end = process
        y_pos = index * 1.5  # Increase vertical spacing between processes

        # Draw the process bar in blue
        ax.broken_barh([(start, end - start)], (y_pos - 0.4, 0.8), facecolors='tab:blue')

        # Draw the second half of CS at the end of the current process
        if cs > 0 and i < len(timeline) - 1:
            cs_start = end
            ax.broken_barh([(cs_start, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:red', alpha=0.5)

        # Draw the first half of CS at the start of the next process
        if cs > 0 and i < len(timeline) - 1:
            next_start = timeline[i + 1][1]
            cs_start_next = next_start - half_cs
            ax.broken_barh([(cs_start_next, half_cs)], ((timeline[i + 1][0] * 1.5) - 0.4, 0.8), facecolors='tab:orange', alpha=0.5)

    # Add CS time at the end of the last process
    if cs > 0:
        last_process_end = timeline[-1][2]
        ax.broken_barh([(last_process_end, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:green', alpha=0.5)

    ax.set_ylim(0, (len(timeline) + 1) * 1.5)
    ax.set_xlim(0, max(t[2] for t in timeline) + cs)
    ax.set_xlabel("Time")
    ax.set_ylabel("Processes")
    ax.set_yticks([t[0] * 1.5 for t in timeline])
    ax.set_yticklabels([f"P{t[0]}" for t in timeline])
    ax.grid(True)
    max_time = max(t[2] for t in timeline) + cs
    ax.set_xticks(range(0, max_time + 1, 2))
    ax.set_title("HRRN Gantt Chart")
    return fig

### SRTF
def srtf(p, at, cbt, cs, quantum):
    current_time = 0
    WT = [0] * p
    TT = [0] * p
    remaining_time = cbt.copy()
    timeline = []
    completed = [False] * p
    completed_count = 0
    last_process = -1
    process_execution_time = [0] * p

    while completed_count < p:
        # Find arrived and not completed processes
        arrived_processes = [
            i for i in range(p)
            if at[i] <= current_time and not completed[i] and remaining_time[i] > 0
        ]

        if not arrived_processes:
            # If no process has arrived, move to next arrival
            next_arrival = min(at[i] for i in range(p) if not completed[i])
            current_time = next_arrival
            continue

        # Find process with shortest remaining time
        current_process = min(arrived_processes, key=lambda x: remaining_time[x])

        # Determine execution time
        if process_execution_time[current_process] >= quantum:
            # Perform context switch and find next shortest process
            current_time += cs
            process_execution_time[current_process] = 0

            # Recalculate arrived processes after context switch
            arrived_processes = [
                i for i in range(p)
                if at[i] <= current_time and not completed[i] and remaining_time[i] > 0
            ]

            if not arrived_processes:
                continue

            # Find new shortest process
            current_process = min(arrived_processes, key=lambda x: remaining_time[x])


        # Execute process

        execution_time = min(
            quantum - process_execution_time[current_process],  # Remaining quantum
            remaining_time[current_process]  # Remaining burst time
        )

        # Update times and tracking
        current_time += execution_time
        remaining_time[current_process] -= execution_time
        process_execution_time[current_process] += execution_time

        # Track timeline
        timeline.append((current_process + 1, current_time - execution_time, current_time))

        # Check if process is completed
        if remaining_time[current_process] == 0:
            completed[current_process] = True
            completed_count += 1
            process_execution_time[current_process] = 0

            # Calculate waiting and turnaround times
            TT[current_process] = current_time - at[current_process]
            WT[current_process] = TT[current_process] - cbt[current_process]
            current_time += cs


    return WT, TT, timeline

def plot_gantt_srtf(timeline, cs):
    fig = Figure(figsize=(10, 6), dpi=100)
    ax = fig.add_subplot(111)
    half_cs = cs / 2  # Compute half of CS time

    for i, process in enumerate(timeline):
        index, start, end = process
        y_pos = index * 1.5  # Increase vertical spacing between processes

        # Draw the process bar in blue
        ax.broken_barh([(start, end - start)], (y_pos - 0.4, 0.8), facecolors='tab:blue')

        # Draw the second half of CS at the end of the current process
        if cs > 0 and i < len(timeline) - 1:
            cs_start = end
            ax.broken_barh([(cs_start, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:red', alpha=0.5)

        # Draw the first half of CS at the start of the next process
        if cs > 0 and i < len(timeline) - 1:
            next_start = timeline[i + 1][1]
            cs_start_next = next_start - half_cs
            ax.broken_barh([(cs_start_next, half_cs)], ((timeline[i + 1][0] * 1.5) - 0.4, 0.8), facecolors='tab:orange', alpha=0.5)

    # Add CS time at the end of the last process
    if cs > 0:
        last_process_end = timeline[-1][2]
        ax.broken_barh([(last_process_end, half_cs)], (y_pos - 0.4, 0.8), facecolors='tab:green', alpha=0.5)

    ax.set_ylim(0, (len(timeline) + 1) * 1.5)
    ax.set_xlim(0, max(t[2] for t in timeline) + cs)
    ax.set_xlabel("Time")
    ax.set_ylabel("Processes")
    ax.set_yticks([t[0] * 1.5 for t in timeline])
    ax.set_yticklabels([f"P{t[0]}" for t in timeline])
    ax.grid(True)
    max_time = max(t[2] for t in timeline) + cs
    ax.set_xticks(range(0, max_time + 1, 2))
    ax.set_title("SRTF Gantt Chart")
    return fig
    



class App(customtkinter.CTk):
    def __init__(self):
        super().__init__()
        ## screen size
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()       
        self.geometry(f"{screen_width}x{screen_height}")
        ## screen
        self.title("OS")
        self.columnconfigure(0, weight=0, minsize=300)
        self.columnconfigure(1, weight=1)
        self.columnconfigure(2, weight=0, minsize=300)
        self.rowconfigure(0, weight=1)
        ## slidebar
        self.sidebar_frame = customtkinter.CTkFrame(self)
        self.sidebar_frame.grid(row=0, column=0, sticky="nsew")   
        self.sidebar_frame.rowconfigure(0, weight=0, minsize=350)
        self.sidebar_frame.rowconfigure(1, weight=1)
        self.sidebar_frame.columnconfigure(0, weight=0, minsize=320)  
        ## Tabview in slide bar (selecting algorithms)
        self.tabview = customtkinter.CTkTabview(self.sidebar_frame)
        self.tabview.grid(row=0, column=0, padx=10, pady=(5, 10), sticky="nsew")
            ## Non-preemptive Tab
        self.tabview.add("Non pre-emptive")
        self.radio_var_non_preemptive = customtkinter.StringVar(value="Non Pre_emptive")
                ## non pre-emptive radio buttons 
        # FCFS
        FCFS=customtkinter.CTkRadioButton(self.tabview.tab("Non pre-emptive"),text=f"FCFS",variable=self.radio_var_non_preemptive,value=f"FCFS")
        FCFS.pack(pady=(20,10))
        # SPN
        SPN=customtkinter.CTkRadioButton(self.tabview.tab("Non pre-emptive"),text=f"SPN",variable=self.radio_var_non_preemptive,value=f"SPN")
        SPN.pack(pady=10)
        # HRRN
        HRRN=customtkinter.CTkRadioButton(self.tabview.tab("Non pre-emptive"),text=f"HRRN",variable=self.radio_var_non_preemptive,value=f"HRRN")
        HRRN.pack(pady=10)
                ## non pre-emptive button
        self.show_button_non_preemptive = customtkinter.CTkButton(self.tabview.tab("Non pre-emptive"),text="choose",command=self.frame0_3)
        self.show_button_non_preemptive.pack(pady=(100,10))
            ## Preemptive Tab
        self.tabview.add("Pre-emptive")
        self.radio_var_preemptive = customtkinter.StringVar(value="Pre-emptive")
                ## pre-emptive radio buttons
        # RR                      
        RR=customtkinter.CTkRadioButton(self.tabview.tab("Pre-emptive"),text=f"RR",variable=self.radio_var_preemptive,value=f"RR")
        RR.pack(pady=(20,10))
        # SRTF
        SRTF=customtkinter.CTkRadioButton(self.tabview.tab("Pre-emptive"),text=f"SRTF",variable=self.radio_var_preemptive,value=f"SRTF")
        SRTF.pack(pady=10)
        # MLFQ
        MLFQ=customtkinter.CTkRadioButton(self.tabview.tab("Pre-emptive"),text=f"MLFQ",variable=self.radio_var_non_preemptive,value=f"MLFQ", command=self.MLFQ)
        MLFQ.pack(pady=10)
                ## pre-emptive button
        self.show_button_preemptive = customtkinter.CTkButton(self.tabview.tab("Pre-emptive"),text="choose",command=self.frame0_2)
        self.show_button_preemptive.pack(pady=(100,10))
        ## frame0 in slide bar (Entry)
        self.frame0 = customtkinter.CTkFrame(self.sidebar_frame)
        self.frame0.grid(row=1, column=0, sticky="nsew", padx=10, pady=(5, 15))
        self.frame0.columnconfigure(0, weight=1)  
        self.frame0.rowconfigure(0, weight=0)     
        self.frame0.rowconfigure(1, weight=1)
        self.label_frame0 = customtkinter.CTkLabel(self.frame0,text="Entry place:",text_color=("#495155", "#D3D8DB"),font=customtkinter.CTkFont(size=20, weight="bold"),corner_radius=5,fg_color="transparent")
        self.label_frame0.grid(row=0, column=0, pady=10, padx=10, sticky="nw")  
            ## button in frame0
        self.button_frame0 = customtkinter.CTkButton(self.frame0, text="draw plot", command=lambda: threading.Thread(target=self.draw_plot).start())
        self.button_frame0.grid(row=3, column=0, sticky="s", padx=10, pady=(5,15))
        ## frame0_1 in frame0 (Inputs)
        self.frame0_1 = customtkinter.CTkFrame(self.frame0)
        self.frame0_1.grid(row=1, column=0, pady=10, padx=10, sticky="nsew")
        ## plot frame
        self.plotframe = customtkinter.CTkFrame(self)
        self.plotframe.grid(row=0, column=1, padx=(10,5), sticky="nsew")
        self.plotframe.columnconfigure(0, weight=1)
        self.plotframe.rowconfigure(1, weight=1)
        self.labelplotframe = customtkinter.CTkLabel(self.plotframe,text="plot frame:",text_color=("#495155", "#D3D8DB"),font=customtkinter.CTkFont(size=20, weight="bold"),corner_radius=5,fg_color="transparent")
        self.labelplotframe.grid(row=0, column=0, pady=10, padx=10, sticky="new")
        self.plotframe1 = customtkinter.CTkFrame(self.plotframe)
        self.plotframe1.grid(row=1, column=0, pady=10, padx=10, sticky="nsew")
        ## informationFrame
        self.infFrame = customtkinter.CTkFrame(self)
        self.infFrame.grid(row=0, column=2, padx=(5,10), sticky="nsew")
        self.infFrame.columnconfigure(0, weight=0, minsize=300)
        self.infFrame.rowconfigure(0, weight=1)
        # self.infFrame.rowconfigure(1,weight=0, minsize=300)
        self.infFrame.rowconfigure(1, weight=0)
        self.infFrame.rowconfigure(2, weight=0)
        results = customtkinter.CTkFrame(self.infFrame)
        results.grid(row=0, column=0, pady=(10,5), padx=10, sticky="nsew")   
        # recommend = customtkinter.CTkFrame(self.infFrame)
        # recommend.grid(row=1, column=0, pady=5, padx=10, sticky="nsew")
        # info_contact = customtkinter.CTkFrame(self.infFrame)
        # info_contact.grid(row=2, column=0, pady=(5,10), padx=10, sticky="nsew")
        button_info = customtkinter.CTkButton(self.infFrame, text="info", command=self.infopage)
        button_contact = customtkinter.CTkButton(self.infFrame, text="contact", command=self.contactpage)
        # info_contact.columnconfigure(0, weight=1)
        # info_contact.rowconfigure(0, weight=0)
        # info_contact.rowconfigure(1, weight=1)
        button_info.grid(row=1, column=0, pady=(15,5), sticky="s")
        button_contact.grid(row=2, column=0, pady=(5,15), sticky="s")
    def infopage(self):
        InfoPage(self)
    def contactpage(self):
        ContactPage(self)
    def MLFQ (self):
        """Create a temporary frame to gather additional MLFQ inputs and confirm selection."""
        # Remove the tabview to make space for the new frame
        self.tabview.grid_forget()
        # Create a new frame in the same location as the tabview
        self.mlfq_frame = customtkinter.CTkFrame(self.sidebar_frame)
        self.mlfq_frame.grid(row=0, column=0, padx=10, pady=(20, 10), sticky="nsew")
        # Add a label to the frame
        label = customtkinter.CTkLabel(self.mlfq_frame, text="Enter MLFQ details here:", font=("Arial", 16))
        label.pack(pady=20)
        # Add a confirm button to remove the frame and restore the tabview
        confirm_button = customtkinter.CTkButton(self.mlfq_frame, text="Confirm", command=lambda: self.after(50, self.remove_mlfq_frame))
        confirm_button.pack(pady=(200,10))
    def remove_mlfq_frame(self):
        """Remove the temporary MLFQ frame and restore the original tabview."""
        self.mlfq_frame.grid_forget()  # Remove the frame
        self.tabview.grid(row=0, column=0, padx=10, pady=(5, 10), sticky="nsew")  # Restore tabview
        self.update_idletasks()
    ## if any pre_emptive algorithm choose
    def frame0_2(self):
        for widget in self.frame0_1.winfo_children():
            widget.destroy()
        for widget in self.plotframe1.winfo_children():
            widget.destroy()
        self.entry0 = customtkinter.CTkEntry(self.frame0_1, placeholder_text="numbers of processes: ")
        self.entry0.grid(row=1, column=0, padx=(20, 0), pady=(20, 20), sticky="nsw")
        self.entry1 = customtkinter.CTkEntry(self.frame0_1, placeholder_text="context swich: ")
        self.entry1.grid(row=2, column=0, padx=(20, 0), pady=(20, 20), sticky="nsw")
        self.entry4 = customtkinter.CTkEntry(self.frame0_1, placeholder_text="quantom time: ")
        self.entry4.grid(row=3, column=0, padx=(20, 0), pady=(20, 20), sticky="nsw")
        self.entry2 = customtkinter.CTkEntry(self.frame0_1, placeholder_text="AT ")
        self.entry2.grid(row=4, column=0, padx=(20, 0), pady=(20, 20), sticky="nsw")
        self.entry3 = customtkinter.CTkEntry(self.frame0_1, placeholder_text="CBT ")
        self.entry3.grid(row=5, column=0, padx=(20, 0), pady=(20, 20), sticky="nsw")
    ## if any Non pre_emptive algorithm choose
    def frame0_3(self):
        for widget in self.frame0_1.winfo_children():
            widget.destroy()
        for widget in self.plotframe1.winfo_children():
            widget.destroy()
        self.entry0 = customtkinter.CTkEntry(self.frame0_1, placeholder_text="numbers of processes: ")
        self.entry0.grid(row=1, column=0, padx=(20, 0), pady=(20, 20), sticky="nsw")
        self.entry1 = customtkinter.CTkEntry(self.frame0_1, placeholder_text="context swich:")
        self.entry1.grid(row=2, column=0, padx=(20, 0), pady=(20, 20), sticky="nsw")
        self.entry2 = customtkinter.CTkEntry(self.frame0_1, placeholder_text="AT ")
        self.entry2.grid(row=3, column=0, padx=(20, 0), pady=(20, 20), sticky="nsw")
        self.entry3 = customtkinter.CTkEntry(self.frame0_1, placeholder_text="CBT")
        self.entry3.grid(row=4, column=0, padx=(20, 0), pady=(20, 20), sticky="nsw")
        self.entry4 = customtkinter.CTkEntry(self.frame0_1, placeholder_text="Quantum time (if applicable):")
        self.entry4.grid(row=5, column=0, padx=(20, 0), pady=(20, 20), sticky="nsw")
        self.entry4.grid_remove()
    def get_inputs(self):
        p = int(self.entry0.get())
        at = list(map(int, self.entry2.get().split())) 
        cbt = list(map(int, self.entry3.get().split()))
        cs= int(self.entry1.get()) if self.entry1.get().isdigit() else 0
        q = int(self.entry4.get()) if hasattr(self, 'entry4') and self.entry4.get().isdigit() else None
        if len(at) != p or len(cbt) != p:
            label = customtkinter.CTkLabel(self.plotframe1,text="Number of AT or CBT entries does not match the number of processes!",text_color="red",font=customtkinter.CTkFont(size=14, weight="bold"))
            label.pack(pady=20)
            return
        else:
            return p, at, cbt, cs, q
    def draw_plot(self):
        # Clear previous chart and error messages
        for widget in self.plotframe1.winfo_children():
            widget.destroy()
        for widget in self.infFrame.winfo_children():
            if isinstance(widget, customtkinter.CTkFrame):  # Keep other sections intact
                for sub_widget in widget.winfo_children():
                    sub_widget.destroy()

        try:
            p, at, cbt, cs, q = self.get_inputs()
            
            selected_algorithm = None
            fig = None
            WT, TT, timeline = [], [], []

            # Check which tab is currently selected
            if self.tabview.get() == "Non pre-emptive":
                selected_algorithm = self.radio_var_non_preemptive.get()
            elif self.tabview.get() == "Pre-emptive":
                selected_algorithm = self.radio_var_preemptive.get()

            # Handle algorithm selection
            if selected_algorithm == "FCFS":
                WT, TT, RT, timeline = fcfs(p, at, cbt, cs)
                fig = plot_gantt_fcfs(timeline, cs)
            elif selected_algorithm == "SPN":
                WT, TT, RT, timeline = spn(p, at, cbt, cs)
                fig = plot_gantt_spn(timeline, cs)
            # elif selected_algorithm == "HRRN":
            #     WT, TT, timeline = hrrn(p, at, cbt, cs)
            #     fig = plot_gantt_hrrn(timeline, cs)
            # elif selected_algorithm == "SRTF":
            #     if q is None:
            #         label = customtkinter.CTkLabel(self.plotframe1, text="Quantum time is required for SRTF!", text_color="red", font=customtkinter.CTkFont(size=14, weight="bold"))
            #         label.pack(pady=20)
            #         return
            #     WT, TT, timeline = srtf(p, at, cbt, cs, q)
            #     fig = plot_gantt_srtf(timeline, cs)
            elif selected_algorithm == "RR":
                if q is None:
                    label = customtkinter.CTkLabel(self.plotframe1, text="Quantum time is required for Round Robin!", text_color="red", font=customtkinter.CTkFont(size=14, weight="bold"))
                    label.pack(pady=20)
                    return
                WT, TT, RT, timeline = round_robin(p, at, cbt, cs, q)
                fig = plot_gantt_rr(timeline, cs)
            else:
                label = customtkinter.CTkLabel(self.plotframe1, text="Please select an algorithm!", text_color="red", font=customtkinter.CTkFont(size=14, weight="bold"))
                label.pack(pady=20)
                return

            # Embed the new Gantt chart figure in the canvas
            if fig:
                canvas = FigureCanvasTkAgg(fig, self.plotframe1)
                canvas_widget = canvas.get_tk_widget()
                canvas_widget.pack(fill="both", expand=True)
                canvas.draw()

            # Display WT and TT results in the results frame
            self.display_results(WT, TT, RT)

        except ValueError:
            label = customtkinter.CTkLabel(self.plotframe1, text="Input error! Please enter valid numbers.", text_color="red", font=customtkinter.CTkFont(size=14, weight="bold"))
            label.pack(pady=20)
            
    def display_results(self, WT, TT, RT):
        """Displays formatted WT and TT lists in a fixed-size results frame."""
        results_frame = self.infFrame.winfo_children()[0]  # Assuming results frame is the first child
        
        # Clear previous results
        for widget in results_frame.winfo_children():
            widget.destroy()

        # Set a fixed size for the results frame to prevent expansion
        results_frame.configure(width=300, height=500)  # Adjust as needed
        results_frame.pack_propagate(False)  # Prevent frame from resizing

        # Create a scrollable frame inside results frame to show content within fixed size
        scrollable_results = customtkinter.CTkScrollableFrame(results_frame, width=280, height=380)
        scrollable_results.pack(fill="both", expand=True, padx=10, pady=10)

        # Add a title for results
        title_label = customtkinter.CTkLabel(scrollable_results, text="Scheduling Results", font=("Arial", 18, "bold"))
        title_label.pack(pady=(10, 5))

        # Display Waiting Time (WT) results
        wt_label_title = customtkinter.CTkLabel(scrollable_results, text="Waiting Times (WT):", font=("Arial", 16, "bold"))
        wt_label_title.pack(pady=(10, 5))

        for i, wt in enumerate(WT, start=1):
            wt_label = customtkinter.CTkLabel(scrollable_results, text=f"WT{i} = {wt}", font=("Arial", 14))
            wt_label.pack(pady=2, padx=5, anchor="w")

        # Display Turnaround Time (TT) results
        tt_label_title = customtkinter.CTkLabel(scrollable_results, text="Turnaround Times (TT):", font=("Arial", 16, "bold"))
        tt_label_title.pack(pady=(10, 5))

        for i, tt in enumerate(TT, start=1):
            tt_label = customtkinter.CTkLabel(scrollable_results, text=f"TT{i} = {tt}", font=("Arial", 14))
            tt_label.pack(pady=2, padx=5, anchor="w")
            
        # Display Response Time (RT) results
        wt_label_title = customtkinter.CTkLabel(scrollable_results, text="Response Times (RT):", font=("Arial", 16, "bold"))
        wt_label_title.pack(pady=(10, 5))
        
        for i, rt in enumerate(RT, start=1):
            wt_label = customtkinter.CTkLabel(scrollable_results, text=f"RT{i} = {rt}", font=("Arial", 14))
            wt_label.pack(pady=2, padx=5, anchor="w")       
        
        # Display Averages
        avg_wt = sum(WT) / len(WT) if WT else 0
        avg_tt = sum(TT) / len(TT) if TT else 0
        avg_rt = sum(RT) / len(RT) if RT else 0
        

        avg_wt_label = customtkinter.CTkLabel(scrollable_results, text=f"Average WT = {avg_wt:.2f}", font=("Arial", 16, "bold"))
        avg_wt_label.pack(pady=(10, 2), padx=5, anchor="w")

        avg_tt_label = customtkinter.CTkLabel(scrollable_results, text=f"Average TT = {avg_tt:.2f}", font=("Arial", 16, "bold"))
        avg_tt_label.pack(pady=(2, 2), padx=5, anchor="w")
        
        avg_tt_label = customtkinter.CTkLabel(scrollable_results, text=f"Average RT = {avg_rt:.2f}", font=("Arial", 16, "bold"))
        avg_tt_label.pack(pady=(2, 10), padx=5, anchor="w")        


app = App()
app.mainloop()
